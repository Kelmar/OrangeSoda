/*************************************************************************/
/*************************************************************************/

#ifndef OS_SYMBOL_H__
#define OS_SYMBOL_H__

/*************************************************************************/

#include <string>
#include <memory>
#include <map>

#include "token.h"

/*************************************************************************/

typedef std::shared_ptr<class Symbol> PSymbol;

class SymbolTable;

/*************************************************************************/

class Symbol
{
public:
    enum class UseType
    {
        Function,
        Variable,
        Parameter, // Like variable but may have special in/out/ref handling.
        Primitive, // Built in type: int, float, double, etc.
        Label,
        Struct, // Value based type
        Enum,
        Set
    };

private:
    friend SymbolTable;

    std::vector<PSymbol> m_parameters;
    SymbolTable *m_parent;
    std::string m_name;

    /* constructor */ Symbol(SymbolTable *parent, const std::string &name)
        : m_parameters()
        , m_parent(parent)
        , m_name(name)
    {
    }

public:
    // Get the symbol table that manages this symbol.
    SymbolTable &Parent() const { return *m_parent; }

    // The literal name of the symbol
    const std::string &name() const { return m_name; }

    /// @brief Get a list of parameters defined on this symbol.
    std::vector<PSymbol> GetParameters() const { return m_parameters; }

    // Add a parameter to this symbol.
    void AddParameter(PSymbol symbol) { m_parameters.push_back(symbol); }

    // The line number the symbol was defined on.
    int lineNumber;

    // The type of symbol defined.
    UseType useType;

    // How a parameter is passed if this is a parameter variable.
    PassByType passBy;

    // Set if this symbol is to be exported from the module.
    bool exporting;

    // Set if this symbol is a constant.
    bool isConst;

    // Set if this symbol is generated by the compiler.
    bool isSpecial;

    // Symbol's base type (if any)
    // Return type for function declarations.
    PSymbol baseType;

    // Type of parsed constant literal.
    Token::Type constType;

    // String of the actual constant literal.
    std::string constLiteral;
};

/*************************************************************************/

/**
 * @brief Checks if supplied symbol type is a type that can be used in a declaration.
 */
constexpr bool isTypeUseType(Symbol::UseType useType)
{
    return
        (useType == Symbol::UseType::Primitive) ||
        (useType == Symbol::UseType::Struct) ||
        (useType == Symbol::UseType::Enum) ||
        (useType == Symbol::UseType::Set)
    ;
}

/*************************************************************************/

template <>
struct fmt::formatter<Symbol::UseType> : formatter<string_view>
{
    auto format(Symbol::UseType useType, format_context &ctx) const
        -> format_context::iterator;
};

/*************************************************************************/

#endif /* OS_SYMBOL_H__ */

/*************************************************************************/
